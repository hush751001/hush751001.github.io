{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../../App.svelte"
  ],
  "sourcesContent": [
    "<script>\n  import { fabric } from \"fabric\";\n  import { onMount } from 'svelte';\n\n  let BORDER_SIZE = 30;\n  let CELL_WIDTH = 100;\n  let CELL_HEIGHT = 34;\n  let Y_GAP = 50;\n  let CHARACTER_SIZE = 40;\n  let ONE_PIXEL = 1;\n\n  let playerCount = 4;\n  let xSize = playerCount;\n  let ySize = 10;\n  let boardSize = {\n    width: (xSize - 1) * CELL_WIDTH + BORDER_SIZE * 2,\n    height: (ySize - 1) * CELL_HEIGHT + BORDER_SIZE * 2 + Y_GAP * 2,\n  };\n  let colors = [\n    '#ff0000',\n    '#ffff00',\n    '#ff00ff',\n    '#00ff00',\n    '#00ffff',\n    '#0000ff',\n    '#ff0000',\n    '#ffff00',\n    '#ff00ff',\n    '#00ff00',\n    '#00ffff',\n    '#0000ff',\n  ];\n  let characters = [\n    '\\uD83D\\uDE05',\n    '\\uD83D\\uDE08',\n    '\\uD83D\\uDE0D',\n    '\\uD83D\\uDE0E',\n    '\\uD83D\\uDE18',\n    '\\uD83D\\uDE31',\n    '\\uD83D\\uDE22',\n    '\\uD83D\\uDE24',\n    '\\uD83D\\uDE26',\n    '\\uD83D\\uDE28',\n    '\\uD83D\\uDE2C',\n    '\\uD83D\\uDE2D',\n  ];\n\n  let board = [];\n  let curPolyline = [];\n\n  let playersData = [];\n  let isAnimating = false;\n  let people = [];\n  let playersIsRunning = [];\n  \n  let canvasEl;\n  fabric.Object.prototype.transparentCorners = false;\n  let fabricCanvas;\n\n  let results = [];\n\n  onMount(() => {\n    initGame();\n  });\n\n  function animate(canvas, obj, playerIndex, params, duration) {\n    return new Promise((resolve) => {\n      people[playerIndex].animate({ top: params.y2 - (CHARACTER_SIZE / 2), left: params.x2 - (CHARACTER_SIZE / 2) }, {\n        duration\n      });\n      obj.animate({ x2: params.x2 - 2, y2: params.y2 - 2 }, {\n        onChange: function() {\n          people[playerIndex].bringToFront();\n          canvas.renderAll.bind(canvas);\n        },\n        onComplete: function() {\n          obj.setCoords();\n          resolve();\n        },\n        duration\n      });\n    });\n  }\n\n  async function runPlayerIndex(canvas, playerIndex) {\n    if (playersIsRunning[playerIndex]) {\n      return;\n    }\n    people[playerIndex].bringToFront();\n    isAnimating = true;\n    const path = playersData[playerIndex];\n    if (curPolyline.length > 0) {\n      canvas.remove(...curPolyline);\n      curPolyline = [];\n    }\n\n    for(let i = 0;i < path.length - 1; i++) {\n      const L = new fabric.Line([path[i].x - 2, path[i].y - 2, path[i].x - 2, path[i].y - 2], {\n        fill: 'transparent', \n        strokeLineJoin: 'round',\n        strokeLineCap: 'round',\n        stroke: colors[playerIndex],\n        strokeWidth: 5 * ONE_PIXEL,\n        selectable: false,\n        evented: false,\n      });\n      curPolyline.push(L);\n    }\n    for(let i = 0;i < path.length - 1; i++) {\n      const L = curPolyline[i];\n      canvas.add(L);\n\n      // pixel에 길이에 해당하는 속도를 계산\n      const duration = Math.abs((path[i].x === path[i + 1].x) ? path[i + 1].y - path[i].y : path[i + 1].x - path[i].x) * 5;\n\n      await animate(canvas, L, playerIndex, {\n        x2: path[i + 1].x,\n        y2: path[i + 1].y\n      }, duration);\n    }\n    isAnimating = false;\n    playersIsRunning[playerIndex] = true;\n  }\n\n  function makeLineWithBlack(coords) {\n    return new fabric.Line(coords, {\n      fill: 'black',\n      stroke: 'black',\n      strokeWidth: 2 * ONE_PIXEL,\n      selectable: false,\n      evented: false,\n    });\n  }\n\n  function initGame() {\n\n    board = [];\n    curPolyline = [];\n    playersData = [];\n    isAnimating = false;\n    people = [];\n    playersIsRunning = [];\n\n    results = Array(playerCount).fill().map((_, i) => i + 1);\n\n    xSize = playerCount;\n    ySize = 10;\n    boardSize = {\n      width: (xSize - 1) * CELL_WIDTH + BORDER_SIZE * 2,\n      height: (ySize - 1) * CELL_HEIGHT + BORDER_SIZE * 2 + Y_GAP * 2,\n    };\n\n    canvasEl.setAttribute('width', (boardSize.width) + 'px');\n    canvasEl.setAttribute('height', (boardSize.height) + 'px');\n\n    let canvas;\n    if (fabricCanvas) {\n      canvas = fabricCanvas;\n      canvas.setWidth(boardSize.width);\n      canvas.clear();\n      canvas.setBackgroundColor('#a4a4a5');\n    } else {\n      canvas = new fabric.Canvas(canvasEl, {\n        backgroundColor: '#a4a4a5',\n        selectionColor: 'transparent',\n        selectionLineWidth: 0,\n      });\n      canvas.on('mouse:down', async function(options) {\n        if (options.target) {\n          if (isAnimating === true) {\n            return;\n          }\n          await runPlayerIndex(canvas, options.target.index);\n        }\n      });\n\n      fabricCanvas = canvas;\n    }\n\n\n    clearBoard();\n    genRandomLines();\n    genPlayerPath();\n\n    const lines = [];\n    for (let x = 0; x < xSize; x++) {\n      const line = makeLineWithBlack([\n        BORDER_SIZE + (CELL_WIDTH * x), BORDER_SIZE,\n        BORDER_SIZE + (CELL_WIDTH * x), boardSize.height - BORDER_SIZE\n      ]);\n      lines.push(line);\n    }\n    for (let x = 0; x < xSize - 1; x++) {\n      for (let y = 0; y < ySize; y++) {\n        if (board[x][y]) {\n          const line = makeLineWithBlack([\n            BORDER_SIZE + (CELL_WIDTH * x), Y_GAP + BORDER_SIZE + (CELL_HEIGHT * y),\n            BORDER_SIZE + (CELL_WIDTH * board[x][y].nextX), Y_GAP + BORDER_SIZE + (CELL_HEIGHT * y)\n          ]);\n          lines.push(line);\n        }\n      }\n    }\n    canvas.add(...lines);\n\n    people = [];\n    for (let x = 0; x < xSize; x++) {\n      var person = new fabric.Text(characters[x], {\n        fontSize: CHARACTER_SIZE,\n        top: BORDER_SIZE - (CHARACTER_SIZE / 2),\n        left: BORDER_SIZE + (CELL_WIDTH * x) - (CHARACTER_SIZE / 2),\n        lockMovementX: true,\n        lockMovementY: true,\n        hasBorders: false,\n        hasControls: false,\n        index: x,\n        hoverCursor: 'pointer'\n      });\n      people.push(person);\n    }\n\n    canvas.add(...people);\n\n  }\n  \n  function clearBoard() {\n    board = [];\n    for (let x = 0; x < xSize; x++) {\n      for (let y = 0; y < ySize; y++) {\n        board[x] = board[x] || [];\n        board[x][y] = null;\n      }\n    }\n  }\n\n  function getRandomIntInclusive(min, max) {\n    min = Math.ceil(min);\n    max = Math.floor(max);\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n\n  function genRandomLines() {\n    // 1. 한 축에 (ySize / 4) ~ (ySize / 2) 만큼의 갯수의 라인을 그린다.\n    for (let x = 0; x < xSize - 1; x++) {\n      let randomLineCount = getRandomIntInclusive(ySize / 4, ySize / 2);\n      while(randomLineCount > 0) {\n        // 1. 0 ~ (ySize - 1) 까지 랜덤\n        const yPos = getRandomIntInclusive(0, ySize - 1);\n        // 2. 기존에 설정되어 있는 지 확인\n        if (board[x][yPos]) continue;\n        // 3. 라인값 설정\n        board[x][yPos] = {\n          nextX: x + 1,\n        };\n        board[x + 1][yPos] = {\n          nextX: x,\n        };\n        randomLineCount--;\n      }\n    }\n  }\n\n  function genPlayerPath() {\n    playersData = [];\n    for (let playerIndex = 0; playerIndex < playerCount; playerIndex++) {\n      let x = playerIndex;\n      let y = 0, preY = 0, preX = x;\n      let path = [];\n      path.push({ x: BORDER_SIZE + (CELL_WIDTH * x), y: BORDER_SIZE });\n\n      do {\n        while(y < ySize) {\n          if (board[x][y]) break;\n          y++;\n        }\n        if (y >= ySize) {\n          path.push({ x: BORDER_SIZE + (CELL_WIDTH * x), y: BORDER_SIZE + Y_GAP + (CELL_HEIGHT * (ySize - 1)) });\n          break;\n        }\n\n        path.push({ x: BORDER_SIZE + (CELL_WIDTH * x), y: BORDER_SIZE + Y_GAP + (CELL_HEIGHT * y) });\n\n        x = board[x][y].nextX;\n\n        path.push({ x: BORDER_SIZE + (CELL_WIDTH * x), y: BORDER_SIZE + Y_GAP + (CELL_HEIGHT * y) });\n\n        preX = x;\n        preY = y;\n        y++;\n      } while(true);\n\n      if (preX === x) {\n        // 마지막껄 지운다.\n        path.pop();\n      }\n\n      path.push({ x: BORDER_SIZE + (CELL_WIDTH * x), y: BORDER_SIZE + Y_GAP + (CELL_HEIGHT * (ySize - 1)) + Y_GAP });\n\n      playersData.push(path);\n    }\n  }\n  \n  function handleStartClick() {\n    initGame();\n  }\n\n  window.onbeforeunload = () => {\n    return '종료 확인?';\n  };\n</script>\n\n<main style=\"overflow:auto;\">\n  <header>\n    <h1>사다리 타기</h1>\n    <div>\n        <input type=\"number\" bind:value={playerCount} min=\"2\" max=\"12\" placeholder=\"참가자수\" />\n        <button on:click={handleStartClick}>시작</button>\n    </div>\n  </header>\n  <div class=\"canvas-wrapper\">\n    <canvas bind:this={canvasEl} />\n    <div class=\"result-inputs\">\n      {#each results as result}\n        <input type=\"text\" bind:value={result} />\n      {/each}\n    </div>\n  </div>\n</main>\n\n<style>\n  main {\n    padding: 0em;\n  }\n\n  header {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n  }\n  h1 {\n    color: #ff3e00;\n  }\n\n  input[type=\"number\"] {\n    width: 60px;\n    margin-left: 20px;\n  }\n\n  :global(.canvas-container) {\n    margin: 0 auto;\n  }\n\n  .canvas-wrapper {\n    overflow: auto;\n  }\n  \n  .result-inputs {\n    display: flex;\n  }\n  .result-inputs input:first-child {\n    margin-left: 5px;\n  }\n  .result-inputs input {\n    width: 50px;\n    margin: 10px 25px;\n  }\n</style>"
  ],
  "names": [],
  "mappings": "AA0UE,IAAI,4BAAC,CAAC,AACJ,OAAO,CAAE,GAAG,AACd,CAAC,AAED,MAAM,4BAAC,CAAC,AACN,OAAO,CAAE,IAAI,CACb,WAAW,CAAE,MAAM,CACnB,eAAe,CAAE,MAAM,AACzB,CAAC,AACD,EAAE,4BAAC,CAAC,AACF,KAAK,CAAE,OAAO,AAChB,CAAC,AAED,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,4BAAC,CAAC,AACpB,KAAK,CAAE,IAAI,CACX,WAAW,CAAE,IAAI,AACnB,CAAC,AAEO,iBAAiB,AAAE,CAAC,AAC1B,MAAM,CAAE,CAAC,CAAC,IAAI,AAChB,CAAC,AAED,eAAe,4BAAC,CAAC,AACf,QAAQ,CAAE,IAAI,AAChB,CAAC,AAED,cAAc,4BAAC,CAAC,AACd,OAAO,CAAE,IAAI,AACf,CAAC,AACD,4BAAc,CAAC,mBAAK,YAAY,AAAC,CAAC,AAChC,WAAW,CAAE,GAAG,AAClB,CAAC,AACD,4BAAc,CAAC,KAAK,cAAC,CAAC,AACpB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CAAC,IAAI,AACnB,CAAC"
}