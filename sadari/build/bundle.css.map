{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../../App.svelte"
  ],
  "sourcesContent": [
    "<script>\n\timport { fabric } from \"fabric\";\n\timport { onMount } from 'svelte';\n\n  const BORDER_SIZE = 40;\n\tconst CELL_WIDTH = 120;\n\tconst CELL_HEIGHT = 44;\n  const Y_GAP = 60;\n  const CHARACTER_SIZE = 40;\n\tlet board = [];\n\n\tlet playerCount = 6;\n\tconst xSize = playerCount;\n\tconst ySize = 10;\n\tconst boardSize = {\n\t\twidth: (xSize - 1) * CELL_WIDTH + BORDER_SIZE * 2,\n\t\theight: (ySize - 1) * CELL_HEIGHT + BORDER_SIZE * 2 + Y_GAP * 2,\n  };\n  let colors = [\n\t\t'#ff0000',\n\t\t'#ffff00',\n\t\t'#ff00ff',\n\t\t'#00ff00',\n\t\t'#00ffff',\n\t\t'#0000ff',\n\t];\n\tlet characters = [\n\t\t'\\uD83D\\uDE05',\n\t\t'\\uD83D\\uDE08',\n\t\t'\\uD83D\\uDE0D',\n\t\t'\\uD83D\\uDE0E',\n\t\t'\\uD83D\\uDE18',\n\t\t'\\uD83D\\uDE31',\n  ];\n  let curPolyline = [];\n\n\tlet playersData = [];\n  let isAnimating = false;\n  let people = [];\n  let playersIsRunning = [];\n  \n  let canvasEl;\n  fabric.Object.prototype.transparentCorners = false;\n\n\tonMount(() => {\n    canvasEl.setAttribute('width', boardSize.width);\n\t\tcanvasEl.setAttribute('height', boardSize.height);\n\t\tlet canvas = new fabric.Canvas(canvasEl, {\n      backgroundColor: '#a4a4a5',\n      selectionColor: 'transparent',\n      selectionLineWidth: 0,\n    });\n    canvas.on('mouse:down', async function(options) {\n      if (options.target) {\n        if (isAnimating === true) {\n          return;\n        }\n        await runPlayerIndex(canvas, options.target.index);\n      }\n    });\n    initGame(canvas);\n  });\n\n  function animate(canvas, obj, playerIndex, params, duration) {\n    return new Promise((resolve) => {\n      people[playerIndex].animate({ top: params.y2 - (CHARACTER_SIZE / 2), left: params.x2 - (CHARACTER_SIZE / 2) }, {\n        duration\n      });\n      obj.animate({ x2: params.x2 - 2, y2: params.y2 - 2 }, {\n        onChange: function() {\n          people[playerIndex].bringToFront();\n          canvas.renderAll.bind(canvas);\n        },\n        onComplete: function() {\n          obj.setCoords();\n          resolve();\n        },\n        duration\n      });\n    });\n  }\n\n  async function runPlayerIndex(canvas, playerIndex) {\n    if (playersIsRunning[playerIndex]) {\n      return;\n    }\n    people[playerIndex].bringToFront();\n    isAnimating = true;\n    const path = playersData[playerIndex];\n    if (curPolyline.length > 0) {\n      canvas.remove(...curPolyline);\n      curPolyline = [];\n    }\n\n    for(let i = 0;i < path.length - 1; i++) {\n      const L = new fabric.Line([path[i].x - 2, path[i].y - 2, path[i].x - 2, path[i].y - 2], {\n        fill: 'transparent', \n        strokeLineJoin: 'round',\n        strokeLineCap: 'round',\n        stroke: colors[playerIndex],\n        strokeWidth: 5,\n        selectable: false,\n        evented: false,\n      });\n      curPolyline.push(L);\n    }\n    for(let i = 0;i < path.length - 1; i++) {\n      const L = curPolyline[i];\n      canvas.add(L);\n\n      // pixel에 길이에 해당하는 속도를 계산\n      const duration = Math.abs((path[i].x === path[i + 1].x) ? path[i + 1].y - path[i].y : path[i + 1].x - path[i].x) * 5;\n\n      await animate(canvas, L, playerIndex, {\n        x2: path[i + 1].x,\n        y2: path[i + 1].y\n      }, duration);\n    }\n    isAnimating = false;\n    playersIsRunning[playerIndex] = true;\n  }\n\n  function makeLineWithBlack(coords) {\n    return new fabric.Line(coords, {\n      fill: 'black',\n      stroke: 'black',\n      strokeWidth: 2,\n      selectable: false,\n      evented: false,\n    });\n  }\n\n  function initGame(canvas) {\n\n    clearBoard();\n    genRandomLines();\n\t\tgenPlayerPath();\n\n    const lines = [];\n    for (let x = 0; x < xSize; x++) {\n      const line = makeLineWithBlack([\n        BORDER_SIZE + (CELL_WIDTH * x), BORDER_SIZE,\n        BORDER_SIZE + (CELL_WIDTH * x), boardSize.height - BORDER_SIZE\n      ]);\n      lines.push(line);\n\t\t}\n    for (let x = 0; x < xSize - 1; x++) {\n\t\t\tfor (let y = 0; y < ySize; y++) {\n\t\t\t\tif (board[x][y]) {\n          const line = makeLineWithBlack([\n            BORDER_SIZE + (CELL_WIDTH * x), Y_GAP + BORDER_SIZE + (CELL_HEIGHT * y),\n            BORDER_SIZE + (CELL_WIDTH * board[x][y].nextX), Y_GAP + BORDER_SIZE + (CELL_HEIGHT * y)\n          ]);\n          lines.push(line);\n\t\t\t\t}\n\t\t\t}\n    }\n    canvas.add(...lines);\n\n    people = [];\n    for (let x = 0; x < xSize; x++) {\n      var person = new fabric.Text(characters[x], {\n        fontSize: CHARACTER_SIZE,\n        top: BORDER_SIZE - (CHARACTER_SIZE / 2),\n        left: BORDER_SIZE + (CELL_WIDTH * x) - (CHARACTER_SIZE / 2),\n        lockMovementX: true,\n        lockMovementY: true,\n        hasBorders: false,\n        hasControls: false,\n        index: x,\n        hoverCursor: 'pointer'\n      });\n      people.push(person);\n    }\n\n    canvas.add(...people);\n\n  }\n  \n  function clearBoard() {\n\t\tboard = [];\n\t\tfor (let x = 0; x < xSize; x++) {\n\t\t\tfor (let y = 0; y < ySize; y++) {\n\t\t\t\tboard[x] = board[x] || [];\n\t\t\t\tboard[x][y] = null;\n\t\t\t}\n\t\t}\n  }\n\n  function getRandomIntInclusive(min, max) {\n\t\tmin = Math.ceil(min);\n\t\tmax = Math.floor(max);\n\t\treturn Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n\n  function genRandomLines() {\n\t\t// 1. 한 축에 (ySize / 4) ~ (ySize / 2) 만큼의 갯수의 라인을 그린다.\n\t\tfor (let x = 0; x < xSize - 1; x++) {\n\t\t\tlet randomLineCount = getRandomIntInclusive(ySize / 4, ySize / 2);\n\t\t\twhile(randomLineCount > 0) {\n\t\t\t\t// 1. 0 ~ (ySize - 1) 까지 랜덤\n\t\t\t\tconst yPos = getRandomIntInclusive(0, ySize - 1);\n\t\t\t\t// 2. 기존에 설정되어 있는 지 확인\n\t\t\t\tif (board[x][yPos]) continue;\n\t\t\t\t// 3. 라인값 설정\n\t\t\t\tboard[x][yPos] = {\n\t\t\t\t\tnextX: x + 1,\n\t\t\t\t};\n\t\t\t\tboard[x + 1][yPos] = {\n\t\t\t\t\tnextX: x,\n\t\t\t\t};\n\t\t\t\trandomLineCount--;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction genPlayerPath() {\n\t\tplayersData = [];\n\t\tfor (let playerIndex = 0; playerIndex < playerCount; playerIndex++) {\n\t\t\tlet x = playerIndex;\n\t\t\tlet y = 0, preY = 0, preX = x;\n\t\t\tlet path = [];\n\t\t\tpath.push({ x: BORDER_SIZE + (CELL_WIDTH * x), y: BORDER_SIZE });\n\n\t\t\tdo {\n\t\t\t\twhile(y < ySize) {\n\t\t\t\t\tif (board[x][y]) break;\n\t\t\t\t\ty++;\n\t\t\t\t}\n\t\t\t\tif (y >= ySize) {\n\t\t\t\t\tpath.push({ x: BORDER_SIZE + (CELL_WIDTH * x), y: BORDER_SIZE + Y_GAP + (CELL_HEIGHT * (ySize - 1)) });\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tpath.push({ x: BORDER_SIZE + (CELL_WIDTH * x), y: BORDER_SIZE + Y_GAP + (CELL_HEIGHT * y) });\n\n\t\t\t\tx = board[x][y].nextX;\n\n\t\t\t\tpath.push({ x: BORDER_SIZE + (CELL_WIDTH * x), y: BORDER_SIZE + Y_GAP + (CELL_HEIGHT * y) });\n\n\t\t\t\tpreX = x;\n\t\t\t\tpreY = y;\n\t\t\t\ty++;\n\t\t\t} while(true);\n\n      if (preX === x) {\n        // 마지막껄 지운다.\n        path.pop();\n      }\n\n\t\t\tpath.push({ x: BORDER_SIZE + (CELL_WIDTH * x), y: BORDER_SIZE + Y_GAP + (CELL_HEIGHT * (ySize - 1)) + Y_GAP });\n\n\t\t\tplayersData.push(path);\n\t\t}\n\t}\n</script>\n\n<main>\n  <h1>사다리 타기</h1>\n\t<canvas bind:this={canvasEl} width=\"500\" height=\"300\" />\n</main>\n\n<style>\n\tmain {\n\t\tpadding: 0em;\n\t}\n\n\th1 {\n\t\tcolor: #ff3e00;\n\t}\n</style>"
  ],
  "names": [],
  "mappings": "AAuQC,IAAI,cAAC,CAAC,AACL,OAAO,CAAE,GAAG,AACb,CAAC,AAED,EAAE,cAAC,CAAC,AACH,KAAK,CAAE,OAAO,AACf,CAAC"
}